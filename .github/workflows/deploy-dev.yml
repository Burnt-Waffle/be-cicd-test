name: Deploy Dev (SSM Helper)

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      image_uri:
        description: '배포할 Docker 이미지 URI (예: .../backend:dev-latest)'
        required: true
        type: string
      instance_tag_name:
        description: 'EC2를 찾을 태그 Key (예: Environment)'
        required: true
        type: string
      instance_tag_value:
        description: 'EC2를 찾을 태그 Value (예: dev)'
        required: true
        type: string

permissions:
  id-token: write
  contents: read

jobs:
  deploy-via-ssm:
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # OIDC를 사용하므로 Role ARN을 Secrets에서 가져옴
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ap-northeast-2

      - name: Find Target Instance
        id: find-instance
        run: |
          echo "Finding instance with tag ${{ inputs.instance_tag_name }}=${{ inputs.instance_tag_value }}..."
          
          # 태그를 이용해서 Running 상태인 인스턴스 ID 찾기
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:${{ inputs.instance_tag_name }},Values=${{ inputs.instance_tag_value }}" "Name=instance-state-name,Values=running" \
            --query "Reservations[*].Instances[*].InstanceId" \
            --output text)

          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" == "None" ]; then
            echo "Error: No running instance found!"
            exit 1
          fi

          echo "Target Instance ID: $INSTANCE_ID"
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_OUTPUT

      - name: Send SSM Command (Docker Compose Up)
        run: |
          echo "Deploying Image: ${{ inputs.image_uri }}"
          
          # SSM 명령 전송 (비동기)
          # 주의: EC2 내부의 docker-compose.yml 경로를 본인 환경에 맞게 수정해야 함 (/home/ec2-user/app 등)
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.find-instance.outputs.INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploying ${{ inputs.image_uri }}" \
            --parameters commands='[
              "echo \"=== Start Deployment ===\"",
              "cd /home/ubuntu", 
              
              "echo \"1. Login to ECR\"",
              "aws ecr get-login-password --region ap-northeast-2 | docker login --username AWS --password-stdin $(echo ${{ inputs.image_uri }} | cut -d/ -f1)",
              
              "echo \"2. Set Environment Variable for Image\"",
              "export BACKEND_IMAGE_URI=${{ inputs.image_uri }}",
              
              "echo \"3. Pull New Image\"",
              "docker compose pull backend",
              
              "echo \"4. Restart Container (Rolling Update style)\"",
              "docker compose up -d backend",
              
              "echo \"5. Cleanup Unused Images\"",
              "docker image prune -f",
              "echo \"=== Deployment Completed ===\""
            ]' \
            --query "Command.CommandId" \
            --output text)

          echo "SSM Command Sent! ID: $COMMAND_ID"
          
          # 명령이 끝날 때까지 대기 및 결과 확인 (Polling)
          echo "Waiting for command execution..."
          while :; do
            STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "${{ steps.find-instance.outputs.INSTANCE_ID }}" --query "Status" --output text)
            
            if [[ "$STATUS" == "Success" ]]; then
              echo "Deployment Successful!"
              exit 0
            elif [[ "$STATUS" == "Failed" || "$STATUS" == "Cancelled" || "$STATUS" == "TimedOut" ]]; then
              echo "Deployment Failed! Status: $STATUS"
              # 실패 원인 로그 출력
              aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "${{ steps.find-instance.outputs.INSTANCE_ID }}" --query "StandardErrorContent" --output text
              exit 1
            fi
            
            echo "Status: $STATUS... Waiting 5s"
            sleep 5
          done